"""
If p is the perimeter of a right angle triangle with integral length sides, {a,b,c}, there are exactly three solutions
for p = 120:

{20,48,52}, {24,45,51}, {30,40,50}.

For which value of p â‰¤ 1000, is the number of solutions maximised?
"""

import math

try:
    import lib
except ModuleNotFoundError:
    from questions import lib


ANSWER = 840


EXPLANATION = """
We can generate pythagorean triples by plugging arbitrary integer values of m and n into:

(a, b, c) = (m^2 - n^2, 2mn, m^2 + n^2) := f(m,n).

But this is prone to generating repeats, negative side lengths, and we also only want to generate triples with
perimeters in a given range.

First let's deal with the negative side lengths:
- For all values of m and n, c = m^2 + n^2 will be positive.
- For a = m^2 - n^2 to be positive (and non-zero) we must have that |m| > |n| (1).
- For b = 2mn to be > 0, m and n must either both be positive or both be negative, and neither can be zero (2).

We will also notice that f(m,n) = f(-m,-n), so to avoid these repeats we can restrict m and n to be positive. This means
that (2) is satisfied, and combining with (1) gives us:

m > n >= 1 (3).

Now let's deal with the perimeter. A triangle with those side lengths generated from f(m,n) will have a perimeter of:

p = a + b + c = m^2 + n^2 + 2mn + m^2 - n^2 = 2m(m+n).

For this to be at most our maximum perimeter, P, we must have:

p = 2m(m+n) <= P,
<=> P/2m - m >= n > 0,
=> m < sqrt(P/2) (4).

So our values of m will the integers in the range [2, sqrt(P/2)).

Then for each value of m, we get a corresponding range of values of n for which the perimeter is below the upper bound:

P >= 2m(m+n)
<=> n <= P/2m - m (6),

remembering from (3) that n is bounded above by m too.

With this setup we will unfortunately miss some pythagorean triples, but no worry - we can form those by taking integer
multiples of the ones we can generate, e.g. (3, 4, 5) -> (6, 8, 10).

However, this will cause some repeats, e.g. f(4,2) = (6, 8, 10) = 2 * f(2,1), so we must only use values of m and n
which share no factors - i.e. m and n must be coprime (7).

One final issue is if m and n are both odd we end up with multiples of other pythagorean triples. Combined with (7)
results in the constraint that m and n must have opposite parity mod 2 (8).

So now we have a strategy:
- loop through values of m
- loop through values of n
- add 1 to the count of the resulting perimeter and all the integer multiples of that perimeter below the maximum.
"""


def coprime(a: int, b: int) -> bool:
    """
    Decide whether two integers are coprime - that is, if they share no factors.

    :param a: an integer.
    :param b: an integer.

    :return: True if a and b are coprime, otherwise False.
    """
    return lib.factors.greatest_common_divisor(a, b) == 1


@lib.profiling.profileit()
def find_perimeter_with_most_combinations(max_incl: int) -> int:
    """
    Find the perimeter of right angle triangle which has the most distinct combinations of integer side lengths for all
    perimeters less than or equal to a maximum.

    :param max_incl: the maximum (inclusive) value of the perimeter.

    :return: the perimeter which has the most possible combinations of integer side lengths.
    """
    perimiter_to_combinations = {perimeter: 0 for perimeter in range(1, max_incl + 1)}
    # Loop through values of m and n which result in a perimeter less than or equal to max_incl:
    for m in range(2, math.ceil(math.sqrt(max_incl / 2))):
        # Choose the more restrictive upper bound on n:
        n_max = min(m - 1, int((max_incl / (2 * m)) - m))
        # m and n must have the opposite parity mod 2:
        n_min = 2 if m % 2 == 1 else 1
        for n in range(n_min, n_max + 1, 2):  # Steps of 2 to maintain parity mod 2
            if coprime(m, n):
                # We have found a primitive pythagorean triple with a perimeter in our range; add one to its count:
                perimeter = 2 * m * (m + n)
                perimiter_to_combinations[perimeter] += 1
                # Also add 1 to the count for the multiples of this perimeter, since they can be formed by taking
                # multiples of each of these side lengths but won't be generated by this way:
                max_multiple = int(max_incl / perimeter)
                multiples = {x for x in range(1, max_multiple + 1)}
                for x in multiples:
                    perimiter_to_combinations[perimeter * x] += 1

    return max(perimiter_to_combinations, key=perimiter_to_combinations.get)


if __name__ == '__main__':

    answer = find_perimeter_with_most_combinations(1000)
