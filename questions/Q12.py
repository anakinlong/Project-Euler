"""
The sequence of triangle numbers is generated by adding the natural numbers. So the 7-th triangle number would be

1 + 2 + ... + 7 = 28.

The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

1: 1
3: 1, 3
6: 1, 2, 3, 6
10: 1, 2, 5, 10
15: 1, 3, 5, 15
21: 1, 3, 7, 21
28: 1, 2, 4, 7, 14, 28

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
"""

try:
    import lib
except ModuleNotFoundError:
    from questions import lib


ANSWER = 76576500


def triangle_number(n: int) -> int:
    """
    Generate the n-th triangle number.

    :param n: a positive integer.

    :return: the n-th triangle number.
    """
    return int(n * (n + 1) / 2)


def count_factors(n: int) -> int:
    """
    Count how many proper factors n has.

    :param n: an integer.

    :return: the number of proper factors of n.
    """
    # Every number has proper factors of 1 and itself:
    n_factors = 2

    # Now we loop through every integer between 1 and the square root of n to prevent repeats:
    for k in range(2, int(n ** (1 / 2) + 1)):
        # If n is divisible by k, add k to the list of proper factors:
        if n % k == 0:
            n_factors += 1

            # If n / k isn't k, i.e. k isn't the square root of n, also add n / k to the list of factors:
            if int(k) != int(n / k):
                n_factors += 1

    return n_factors


# TODO not super happy with the slowness of testing every single triangle number
@lib.profiling.profileit()
def find_highly_divisible_triangle_number(min_excl: int) -> int:
    """
    Find the first triangle number to have more than a given number of divisors (proper factors).

    :param min_excl: the number of divisors the triangle number must have more than.

    :return: the highly divisible triangle number.
    """
    # Simply loop through all the triangle numbers and check whether it has enough divisors:
    n = 1
    found = False
    while not found:
        current_triangle_number = triangle_number(n)
        # n_divisors = len(set(factors(current_triangle_number)))
        n_divisors = count_factors(current_triangle_number)

        if n_divisors > min_excl:
            found = True

            return current_triangle_number

        n += 1


if __name__ == '__main__':

    answer = find_highly_divisible_triangle_number(500)
